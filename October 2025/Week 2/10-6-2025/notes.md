# Problem 202. Happy Number - Notes

## Problem Understanding
- A number is happy if repeatedly replacing it with the sum of squares of its digits eventually reaches 1
- If the process never reaches 1 the sequence enters a cycle that excludes 1
- Return true if n is happy and false otherwise

## Approach
### Initial Thoughts
- Define next(n) as the sum of squares of the digits of n
- The sequence generated by repeatedly applying next is bounded and must reach 1 or loop
- Loop detection can use a seen set or Floyd two pointers

### Approach Taken
- Solution 1 uses an unordered_set to record seen values and stops if a value repeats
- Solution 1 computes next(n) by extracting digits with n % 10 and adding d*d to a running sum then sets n to that sum
- Solution 1 intends to terminate when n becomes 1 and the better check is n == 1 rather than any floating point heuristic
- After Solution 1 worked a discovery step tested all single digits 0 through 9 to look for convergence patterns
- That test showed only 1 and 7 as single digits eventually reach 1 while others fall into the unhappy cycle that includes 4
- Solution 2 uses this pattern by repeatedly transforming n and returning true when n is 1 or 7 and n is a single digit otherwise returning false
- Solution 2 uses only a few scalar variables and no extra data structures

### Complexity:
- **Time:** `O(log n)` per next(n) evaluation with a small constant number of iterations overall so `O(log n)` total for both implementations
- **Space:** Solution 1 uses a set so strict analysis is `O(log n)` while in practice values shrink to a small constant range so it behaves like `O(1)` and Solution 2 is `O(1)`

<!--
## Challenges
### Obstacles Faced
- 
### Edge Cases
- 
-->

## Alternative Solutions
- Floyd cycle detection
  - Maintain slow = next(n) and fast = next(next(n)) and stop when fast becomes 1 or slow equals fast
  - Uses constant space with the same termination behavior
- One or four stop rule
  - Iterate until n is 1 or 4 and return true for 1 and false for 4
  - Equivalent to the single digit 1 or 7 shortcut and works without storing seen values

## Key Takeaways
- This problem is cycle detection over an iterated digit function
- A hash set is simple and reliable while Floyd two pointers gives constant space
- Equality checks with n == 1 avoid floating point pitfalls
- Probing digits 0 through 9 reveals the 1 and 7 shortcut and builds intuition
